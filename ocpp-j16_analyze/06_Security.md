# 6. Security (보안)

> 출처: ocpp-j-1.6-specification.pdf, Chapter 6
> 작업 유형: 완전 번역 (Full Translation) - 텍스트 복붙 기반

OCPP-J의 보안을 위한 두 가지 접근 방식이 존재한다. 네트워크 수준 보안에 의존하거나 OCPP-J over TLS를 사용할 수 있다. 두 가지 접근 방식 모두 아래에 설명되어 있다.

항상 이러한 접근 방식 중 하나가 사용되는 것이 중요하다. 실질적으로 이것은 중앙 시스템이 인터넷으로부터 들어오는 암호화되지 않은 OCPP-J 연결을 수신해서는 안 된다는 것을 의미한다.

## 6.1. Network-level security (네트워크 수준 보안)

보안을 위해 네트워크 수준의 보안에 의존할 수 있다. 이것은 역사적으로 OCPP-S에서 수행되어 왔으며, 적절하게 설정된 네트워크에서는 추가 암호화 또는 인증 조치 없이 OCPP-J를 사용할 수도 있다.

## 6.2. OCPP-J over TLS

그러나 때때로 충전기와 중앙 시스템 간에 보안 네트워크를 사용할 수 없는 경우가 있다. 이 경우 OCPP-J over TLS를 사용할 수 있다. 이 섹션에서는 이것이 어떻게 수행되는지 설명한다.

OCPP 통신에 필요한 보안은 실제로 두 가지 별도의 기능으로 구성된다: 암호화와 충전기 인증.

**암호화(Encryption)**는 OCPP 메시지가 암호화되어 권한이 없는 제3자가 교환된 메시지를 볼 수 없음을 의미한다.

**충전기 인증(Charge point authentication)**은 중앙 시스템이 충전기의 신원을 확인할 수 있음을 의미하며, 이로써 권한이 없는 제3자가 충전기인 척 하며 중앙 시스템에 악의적인 메시지를 보낼 수 없다.

### 6.2.1. Encryption (암호화)

인터넷에서 암호화를 위한 업계 표준은 TLS(Transport Layer Security) [RFC5246]이다. 따라서 OCPP도 중앙 시스템과 충전기 간의 연결을 암호화하기 위해 이 프로토콜을 채택하고 있다. WebSocket과 함께 TLS는 라이브러리에서 널리 지원되며 클라이언트의 경우 암호화되지 않은 WebSocket을 사용하는 것보다 거의 더 어렵지 않아야 한다.

TLS를 사용할 때 중앙 시스템은 충전기가 중앙 시스템의 신원을 확인하는 데 사용할 수 있는 서명된 인증서를 제공할 수도 있다.

일부 충전기 구현은 제한된 컴퓨팅 리소스를 가진 임베디드 시스템을 사용하고 있으므로 서버 측의 TLS 구성에 추가 제한 사항을 부과한다:

- TLS 인증서는 2048바이트 이하의 크기를 가진 RSA 인증서여야 한다 (SHALL)

### 6.2.2. Charge point authentication (충전기 인증)

인증을 위해 OCPP-J over TLS는 HTTP Basic 인증 스킴([RFC2617])을 사용한다. 연결이 이미 TLS로 암호화되어 있기 때문에 비교적 간단한 HTTP Basic 인증을 사용할 수 있으며, 자격 증명을 두 번 암호화할 필요가 없다.

HTTP Basic 인증을 사용할 때 클라이언트, 즉 충전기는 요청과 함께 사용자 이름과 비밀번호를 제공해야 한다. 사용자 이름은 충전기 ID와 동일하며, 이는 충전기가 OCPP-J 연결 URL에서 사용하는 충전기의 식별 문자열이다. 비밀번호는 충전기에 저장된 20바이트 키이다.

#### Example (예제)

다음과 같은 충전기가 있는 경우:
- 충전기 ID "AL1000"
- 인증 키 `0001020304050607FFFFFFFFFFFFFFFFFFFFFFFF`

HTTP 인증 헤더는 다음과 같아야 한다:

```
Authorization: Basic QUwxMDAwOgABAgMEBQYH////////////////
```

#### A note on encryption (암호화에 대한 참고 사항)

HTTP Basic Authentication을 통한 인증 메커니즘은 TLS로 암호화된 연결에서 사용되도록 되어 있다. 암호화되지 않은 연결에서 이 메커니즘을 사용하면 충전기와 중앙 시스템 간의 네트워크 트래픽을 볼 수 있는 사람은 누구나 충전기 자격 증명을 볼 수 있으며, 따라서 충전기를 가장할 수 있다.

#### Setting the charge point's credentials (충전기 자격 증명 설정)

이 충전기 인증 스킴의 경우 충전기는 인증 키를 가져야 한다. 이 인증 키는 어떤 방식으로든 충전기로 전송되어야 한다. 좋은 방법이 무엇인지는 충전기 제조업체와 중앙 시스템 운영자의 비즈니스 모델에 따라 다르다.

#### Setting during or before installation (설치 중 또는 설치 전 설정)

원하는 안전한 상황은 모든 충전기가 고유한 인증 키를 가지는 것이다. 인증 키가 고유하지 않으면 단일 충전기의 인증 키를 발견한 공격자가 운영자의 중앙 시스템에서 많은 또는 모든 충전기를 가장할 수 있다.

이를 달성하는 가장 간단한 방법은 제조 또는 설치 중에 충전기에 인증 키를 설치하는 것이다. 이러한 경우 키는 OCPP 외부의 통신 채널을 통해 중앙 시스템 운영자와 설치자 또는 제조업체 간에 안전하게 통신된다. 이 시나리오는 키가 보안을 위한 채널을 통해 전송되지 않기 때문에 안전하며, 따라서 충전기와 중앙 시스템 간의 연결을 도청하는 공격자가 충전기를 가장할 수 없다.

#### Setting the key over OCPP (OCPP를 통한 키 설정)

충전기의 제조, 판매 및 설치 프로세스가 중앙 시스템 운영자의 통제하에 있지 않은 경우, 각 개별 충전기에 고유한 키를 넣고 중앙 시스템 운영자가 이러한 키와 해당 충전기를 알 수 있도록 하는 방법이 없다. 이러한 시나리오의 경우 시리즈의 모든 충전기가 공장을 떠나 설치될 때 동일한 "마스터" 키를 갖거나 동일한 알고리즘으로 충전기 ID에서 파생된 키를 갖는 것이 바람직하다. 그러나 중앙 시스템 운영자는 마스터 키가 유출된 경우 적대자가 시리즈의 모든 충전기를 가장하지 못하도록 하고자 할 것이다. 이 사용 사례를 위해 중앙 시스템이 충전기 설치 후 OCPP를 통해 충전기에 고유한 키를 보낼 수 있는 가능성이 있다.

OCPP를 통해 충전기의 인증 키를 설정하려면 중앙 시스템은 충전기에 키가 `AuthorizationKey`이고 값이 20바이트 인증 키의 40자 16진수 표현인 `ChangeConfiguration.req` 메시지를 보내야 한다 (SHALL). 충전기가 이 `ChangeConfiguration.req`에 상태가 `Accepted`인 `ChangeConfiguration.conf`로 응답하면 중앙 시스템은 인증 키 변경이 성공했다고 가정해야 하며(SHALL), 더 이상 충전기가 이전에 사용한 자격 증명을 수락하지 않아야 한다. 충전기가 `ChangeConfiguration.req`에 상태가 `Rejected` 또는 `NotSupported`인 `ChangeConfiguration.conf`로 응답하면 중앙 시스템은 이전 자격 증명을 계속 수락해야 한다(SHALL). 이 경우 중앙 시스템은 충전기로부터의 OCPP-J 연결을 여전히 수락해야 하지만(SHALL), 충전기의 OCPP 메시지를 다르게 처리할 수 있다(MAY). 예를 들어 충전기의 부트 알림을 수락하지 않을 수 있다.

![충전기 온보딩 및 새 인증 키 설정 시퀀스 다이어그램](image.png)

충전기는 `GetConfiguration` 요청에 대한 응답으로 인증 키를 반환해서는 안 된다. `AuthorizationKey` 키를 전혀 보고하지 않거나 실제 인증 키와 관련이 없는 값을 반환할 수 있다.

보안해야 할 채널을 통해 키를 보내는 것은 일반적으로 좋지 않은 관행으로 간주되지만, 여기서는 적어도 그렇게 할 수 있는 가능성을 제공하는 것이 적절하다고 생각한다. 일반적으로 인증 키는 충전기가 중앙 시스템에 처음 '온보딩'될 때 설정된다. 충전기가 나중에 온보딩 중에 설정된 키를 생성하면 적어도 이것이 온보딩 중에 연결된 것과 동일한 시스템임을 의미한다. 모든 새 충전기에 대한 단일 "마스터" 키를 알고 있는 적대자에게 스푸핑된 새 충전기를 성공적으로 온보딩하는 것이 가능할 수 있지만, 이미 설치되어 작동 중인 충전기인 척 하는 것은 불가능하다. 이것은 여전히 여러 가지 생각할 수 있는 공격을 불가능하게 만든다:

- 점유된 것으로 표시하는 스푸핑 메시지로 충전기를 "예약"
- 공용 충전기에서 방금 시작한 세션을 중지된 것으로 표시하여 비용을 덜 지불
- 이미 온보딩된 충전기에서 많은 스푸핑된 트랜잭션 및/또는 오류를 보내 중앙 시스템 운영자의 운영을 혼란스럽게 만듦
- 다른 사람의 토큰 ID로 스푸핑된 트랜잭션을 중앙 시스템에 보내 토큰 ID 소유자에게 재정적 피해를 입힘

중앙 시스템 운영자는 OCPP 1.6의 새로운 Pending 값을 사용하여 인증 키 설정을 충전기 온보딩 절차의 일부로 만드는 것이 권장된다. 새로 연결하는 충전기는 첫 번째 `BootNotification.conf`에서 먼저 Pending 등록 상태를 받는다. 그런 다음 중앙 시스템은 `ChangeConfiguration.req`로 충전기의 고유 인증 키를 설정한다. 이 `ChangeConfiguration.req`가 상태가 `Accepted`인 `ChangeConfiguration.conf`로 응답된 경우에만 중앙 시스템은 부트 알림에 대해 `Accepted` 등록 상태로 응답한다.

중앙 시스템 운영자는 새로 연결하는 충전기의 이상 징후를 확인하는 것이 권장된다. 따라서 공격자가 마스터 키 또는 키 파생 알고리즘과 등록된 충전기 ID 목록을 도용했는지 감지할 수 있다. 예를 들어 새 충전기가 연결되는 속도가 갑자기 증가하면 공격을 나타낼 수 있다.

#### Storing the credentials (자격 증명 저장)

자격 증명이 충전기에 쉽게 손실되거나 재설정되지 않는 방식으로 저장되는 것이 중요하다. 자격 증명이 손실, 삭제 또는 일방적으로 변경되면 충전기는 더 이상 중앙 시스템에 연결할 수 없으며 새 자격 증명을 설치하려면 현장 서비스가 필요하다.

중앙 시스템 측에서는 패스워드의 안전한 저장을 위해 설계된 암호화 해시 알고리즘을 사용하여 고유한 솔트와 함께 인증 키를 해시하여 저장하는 것이 권장된다. 이렇게 하면 충전기의 인증 키가 포함된 데이터베이스가 유출되더라도 공격자가 여전히 중앙 시스템에 충전기로 인증할 수 없다.

### 6.2.3. What it does and does not secure (보안이 제공하는 것과 제공하지 않는 것)

이러한 보안 조치의 범위는 충전기와 중앙 시스템 간 연결의 인증 및 암호화로 제한된다. 이것은 EV 충전 IT 환경의 모든 현재 보안 문제를 다루지는 않는다.

**제공하는 것:**

- 충전기에서 중앙 시스템으로의 인증 (HTTP Basic Authentication 사용)
- 충전기와 중앙 시스템 간 연결의 암호화
- 중앙 시스템에서 충전기로의 인증 (TLS 인증서 사용)

**제공하지 않는 것:**

- 미터 값이 미터와 중앙 시스템 사이에서 변조되지 않았다는 보장
- 운전자의 인증
- 충전기를 물리적으로 변조하는 것에 대한 보호

### 6.2.4. Applicability to OCPP-S (OCPP-S에 대한 적용 가능성)

OCPP-J over TLS 접근 방식은 OCPP-S에 적용할 수 없다. 두 가지 이유가 있다.

첫째, OCPP-S에서는 모든 요청-응답 교환에 대해 새 TCP 연결이 생성된다. 따라서 각 요청-응답 교환에 대해 새로운 TLS 핸드셰이크를 수행해야 하며, 이는 큰 대역폭 오버헤드를 발생시킨다.

둘째, OCPP-S에서는 충전기도 서버 역할을 하므로 서버 인증서가 필요하다. 매우 많은 서버 인증서와 해당 충전기를 추적하는 것은 큰 관리 부담이 될 것이다.

